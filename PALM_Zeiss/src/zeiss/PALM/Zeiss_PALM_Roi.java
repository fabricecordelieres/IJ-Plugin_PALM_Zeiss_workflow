package zeiss.PALM;
import ij.gui.PointRoi;
import ij.gui.PolygonRoi;
import ij.gui.Roi;

import java.awt.Point;
import java.awt.Polygon;
import java.util.ArrayList;

/**
 * This class handles manipulation of single Rois from element files generated by the Zeiss PALM system
 * @author Fabrice P. Cordeli√®res, fabrice.cordelieres@gmail.com
 *
 */
public class Zeiss_PALM_Roi {
	/**Roi type: Rectangle**/
	public static final int RECTANGLE=0;
	
	/**Roi type: Circle**/
	public static final int CIRCLE=1;
	
	/**Roi type: Dot**/
	public static final int DOT=2;
	
	/**Roi type: Freehand**/
	public static final int FREEHAND=3;
	
	/**Roi type: Line**/
	public static final int LINE=4;
	
	
	/** Roi type**/
	int type;
	
	/**Roi color**/
	String color;
	
	/**Roi thickness**/
	int thickness;
	
	/**Roi number**/
	int number;
	
	/**Current Roi number**/
	static int currentNumber=1;
	
	/**Coordinates of the point used to catapult the cut out**/
	Point cutShot;
	
	/**Roi area**/
	double area;
	
	/**Comments associated to the Roi**/
	String comment;
	
	/**List of coordinates for the Roi**/
	ArrayList<Zeiss_PALM_Point> coordinates=new ArrayList<Zeiss_PALM_Point>();
	
	
	/**
	 * Creates a new Zeiss PALM Roi, based on an input String, extracted from an element file
	 * @param infos the String extracted from an element file, to be parsed
	 */
	public Zeiss_PALM_Roi(String infos){
		decode(infos);
	}
	
	/**
	 * Creates a Zeiss PALM Roi from an ImageJ Roi
	 * @param IJRoi the ImageJ Roi to convert
	 * @param infos images infos required to locate Roi
	 */
	public Zeiss_PALM_Roi(Roi IJRoi, Zeiss_PALM_Image_Infos infos){
		//Set type and color
		int IJRoiType=IJRoi.getType();
		switch(IJRoiType){
			case Roi.FREELINE: type=FREEHAND; color="green"; break;
			case Roi.FREEROI: type=FREEHAND; color="green"; break;
			case Roi.LINE: type=LINE; color="blue";break;
			case Roi.OVAL: type=CIRCLE; color="green";break;
			case Roi.POINT: type=DOT; color="red";break;
			case Roi.POLYGON: type=FREEHAND; color="green"; break;
			case Roi.POLYLINE: type=FREEHAND; color="green"; break;
			case Roi.RECTANGLE: type=RECTANGLE; color="green"; break;
			default: type=FREEHAND; color="green"; break;
		}
		
		//Set thickness
		thickness=(int) IJRoi.getStrokeWidth();
		
		//Set number
		number=currentNumber++;
		
		//Set cutshot
		cutShot=new Point(0, 0);
		
		//Set area;
		//area=IJRoi.getMask().getPixelCount();
		area=IJRoi.getStatistics().pixelCount;
		
		//Set comment
		comment="ROI imported from ImageJ";
		
		//Set coordinates
		Polygon pol=IJRoi.getPolygon();
		for(int i=0; i<pol.npoints; i++) coordinates.add(new Zeiss_PALM_Point(pol.xpoints[i], pol.ypoints[i]));
		
		convertCoordinatesFromImageToZeiss(infos);
	}
	
	/**
	 * Decodes a String extracted from an element file
	 * @param infos the String extracted from an element file, to be parsed
	 */
	public void decode(String infos){
		String[] elements=infos.split("\t");
		
		type=getRoiType(elements[0]);
		color=elements[1];
		thickness=Integer.parseInt(elements[2]);
		number=Integer.parseInt(elements[3]);
		
		String[] splitCutShot=elements[4].split(",");
		cutShot=new Point(Integer.parseInt(splitCutShot[0]), Integer.parseInt(splitCutShot[1]));
		
		area=Double.parseDouble(elements[5]);
		
		comment=elements[6];
		
		String[] coordinateSets=infos.substring(infos.indexOf(".\t")+2).replace("\n", "").replace(".\t", "\t").split("\t");
		for(int i=0; i<coordinateSets.length; i++) coordinates.add(new Zeiss_PALM_Point(coordinateSets[i]));
	}
	
	
	/**
	 * Returns the name of the Roi type as a String
	 * @param roiType the Roi type, as a Integer
	 * @return the name of the Roi type as a String
	 */
	public String getRoiType(int roiType){
		if(roiType==RECTANGLE) return "Rectangle";
		if(roiType==CIRCLE) return "Circle";
		if(roiType==DOT) return "Dot";
		if(roiType==FREEHAND) return "Freehand";
		if(roiType==LINE) return "Line";
		return "Unknown";
	}
	
	/**
	 * Returns the Roi type number based on the Roi type name provided as a string
	 * @param roiType the Roi type, as a String
	 * @return the name of the Roi type as an Integer
	 */
	public int getRoiType(String roiType){
		if(roiType.equals("Rectangle")) return RECTANGLE;
		if(roiType.equals("Circle")) return CIRCLE;
		if(roiType.equals("Dot")) return DOT;
		if(roiType.equals("Freehand")) return FREEHAND;
		if(roiType.equals("Line")) return LINE;
		return -1;
	}
	
	
	/**
	 * Converts the Zeiss PALM Roi into an ImageJ Roi
	 * @param infos images infos required to locate Roi
	 * @return the Roi at the ImageJ format
	 */
	public Roi getImageJRoi(Zeiss_PALM_Image_Infos infos){
		int[][] convertedCoord=getConvertedCoordinates(infos);
		
		Roi roi=null;
		
		switch(type){
			case RECTANGLE:
				roi=new Roi(convertedCoord[0][0], convertedCoord[1][0], convertedCoord[0][1]-convertedCoord[0][0]+1, convertedCoord[1][1]-convertedCoord[1][0]+1);
				break;
			case DOT:
				roi=new PointRoi(convertedCoord[0][0], convertedCoord[1][0]);
				break;
			case CIRCLE:
			case FREEHAND:
				roi=new PolygonRoi(convertedCoord[0], convertedCoord[1], convertedCoord[0].length, Roi.POLYGON);
				break;
			case LINE:
				roi=new PolygonRoi(convertedCoord[0], convertedCoord[1], convertedCoord[0].length, Roi.POLYLINE);
				break;
		}
		roi.setName(number+"");
		return roi;
	}
	
	public int[][] getConvertedCoordinates(Zeiss_PALM_Image_Infos infos){
		int[][] out=new int[2][coordinates.size()];
		
		for(int i=0; i<coordinates.size(); i++){
			Zeiss_PALM_Point point=coordinates.get(i).convertFromZeissToImage(infos);
			out[0][i]=(int) point.x;
			out[1][i]=(int) point.y;
		}
		
		return out;
	}
	
	/**
	 * Converts a Zeiss PALM Roi into an ImageJ Roi
	 * @param infos images infos required to locate Roi
	 */
	public void convertCoordinatesFromZeissToImage(Zeiss_PALM_Image_Infos infos){
		for(int i=0; i<coordinates.size(); i++) coordinates.set(i, coordinates.get(i).convertFromZeissToImage(infos));
	}
	
	/*
	public int[][] convertCoordinatesFromImageToZeiss(Zeiss_PALM_Point position, Zeiss_PALM_Point imageDimensions, Zeiss_PALM_Point calibration){
		int[][] out=new int[2][coordinates.size()];
		
		for(int i=0; i<coordinates.size(); i++){
			Zeiss_PALM_Point point=coordinates.get(i).convertFromImageToZeiss(position, imageDimensions, calibration);
			out[0][i]=(int) point.x;
			out[1][i]=(int) point.y;
		}
		
		return out;
	}
	*/
	
	/**
	 * Converts an ImageJ Roi into a Zeiss PALM Roi 
	 * @param infos images infos required to locate Roi
	 */
	public void convertCoordinatesFromImageToZeiss(Zeiss_PALM_Image_Infos infos){
		for(int i=0; i<coordinates.size(); i++) coordinates.set(i, coordinates.get(i).convertFromImageToZeiss(infos));
	}
	
	/**
	 * Move the Zeiss_PALM_Roi to a new location, based on a translation vector
	 * @param translation the translation to be applied
	 */
	public void move(Zeiss_PALM_Point translation){
		for(int i=0; i<coordinates.size(); i++) coordinates.get(i).move(translation);
	}
	
	/**
	 * Rounds the area value: 3 digits for decimal values, unless the area is an integer (no decimals diplayed) or zero (0.0 diplayed)
	 * @return the rounded area, according to Zeiss' nomenclature
	 */
	public String roundArea(){
		String out="";
		if(area==0) out="0.0";
		
		String areaString=area+"";
		String integerPart=areaString.substring(0, areaString.lastIndexOf("."));
		String decimalPart=areaString.substring(areaString.lastIndexOf(".")+1, areaString.length());
		
		if(!integerPart.equals("0") && decimalPart.equals("0")){
			out=integerPart;
		}else{
			if(integerPart.equals("0")){
				out="0.000";
			}else{
				if(decimalPart.length()>3)decimalPart=decimalPart.substring(0, 4);
				while(decimalPart.length()<3) decimalPart+="0";
				out=integerPart+"."+decimalPart;
			}
		}
		return out;
	}
	
	@Override
	public String toString(){
		String out=getRoiType(type)+"\t"
					+color+"\t"
					+thickness+"\t"
					+number+"\t"
					+cutShot.x+","+cutShot.y+"\t"
					+roundArea()+"\t" //Remove the leading .0
					+comment+"\t\n.";
		
		int index=0;
		for(int i=0; i<coordinates.size(); i++){
			out+="\t"+coordinates.get(i).toString();
			index++;
			
			if((type==CIRCLE && i==1 || index==5) && i!=coordinates.size()-1){
				out+="\n.";
				index=0;
			}
		}
		
		if(!(type==RECTANGLE || type==DOT) && index<5 && coordinates.size()!=2) out+="\t";
		
		return out;
	}
}
